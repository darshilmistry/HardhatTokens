{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/ERC20/Coin.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./IERC20.sol\";\n\ncontract Coin is IERC20 {\n\n//  events\n    event Coin_AtemptToUpdateSupply( address from );\n    event Coin_SupplyAltered( uint256 newSupply, uint256 change );\n    event Coin_AttemptToapprove(address sender, address spender);\n    event Coin_AllowanceSpent(address owner, address spender, uint256 amount);\n\n//  immutables\n    address immutable private i_owner;\n\n\n//  errors\n    error Coin__invalidAddress(\n        address invalidEntry\n    );\n    error Coin__trespassing();\n    error Coin__attemptToOverspendAllowances(address owner, address spender);\n\n//  modifiers\n    modifier authorizedPesonnelOnly() {\n        if(msg.sender != i_owner) revert Coin__trespassing();\n        _;\n    }\n\n//  mappings\n    mapping(address => uint256) private balances;\n    mapping(address => mapping(address => uint256)) private allowances;\n\n//  variables\n    uint256 private TotalSupply;\n    string name;\n    string symbol;\n    uint8 decimals = 18;\n\n\n//  constructor\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n        i_owner = msg.sender;\n    }\n\n//  transaction functions\n    function mintCoin(uint256 amount) public authorizedPesonnelOnly{\n        address _sender = msg.sender;\n        emit Coin_AtemptToUpdateSupply( _sender );\n        TotalSupply += amount;\n        balances[ i_owner ] += amount;\n        emit Coin_SupplyAltered( TotalSupply, amount );\n        \n    }\n\n    function burnCoins(uint256 amount) public authorizedPesonnelOnly {\n        address _sender = msg.sender;\n        emit Coin_AtemptToUpdateSupply( _sender );\n        if(_sender == address(0)) revert Coin__invalidAddress(_sender);\n        \n        TotalSupply -= amount;\n        balances[_sender] -= amount;\n        emit Coin_SupplyAltered( TotalSupply, amount );\n        \n    }\n\n    function transfer(address from, address to, uint256 amount) public returns(bool) {\n        bool success = false;\n        if(to == address(0)) {\n            revert Coin__invalidAddress(to);\n        }\n        else {\n            unchecked {\n                balances[ from ] -= amount;\n                balances[ to ] += amount;\n                success = true;\n            }\n            emit Transfer(\n                from, to, amount\n            );\n        }\n        return success;\n    }\n\n    function approve(address spender, uint256 amount) public returns(bool){\n        address sender = msg.sender;\n        bool success = false;\n        emit Coin_AttemptToapprove(sender, spender);\n        if(spender == address(0)) revert Coin__invalidAddress(spender);\n\n        allowances[sender][spender] = amount;\n        success = true; \n        \n        emit Approval(sender, spender, amount);\n        return success;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n        bool success = false;\n        if(from == address(0)) revert Coin__invalidAddress(from);\n        if(to == address(0)) revert Coin__invalidAddress(to);\n\n        spendAllowances(from, msg.sender, amount);\n        transfer(from, to, amount);\n        success = true;\n\n        return success;\n    \n    }\n    \n    function spendAllowances(address owner, address spender, uint256 amount) public {\n        uint256 _allowance = allowances[owner][spender];\n\n        if(amount > _allowance) revert Coin__attemptToOverspendAllowances(owner, spender);\n\n        allowances[owner][spender] -= amount;\n\n        emit Coin_AllowanceSpent(owner, spender, amount);\n\n    }\n\n\n//  public view/pure function\n\n    function whoIsOwner() public view returns(address) {\n        return i_owner;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return TotalSupply;\n    }\n\n    function balanceOf(address account) public view override returns(uint256) {\n        return balances[account];\n    }\n\n    \n    function allowance(address owner, address spender) public override view returns (uint256) {\n        return allowances[owner][spender];\n    }\n\n}"
    },
    "contracts/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n\ninterface IERC20 {\n\n//  events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n//  transaction functions    \n    function transfer(address from, address to, uint256 amount) external returns (bool);\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n//  public view function\n    \n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n}"
    },
    "contracts/ERC721/ERC721Reciever.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ERC721Reciever {\n    \n    function onERC721Recieved(\n        address operator,\n        address from, \n        uint256 tokenId,\n        bytes calldata data\n    ) external returns(bytes4);\n\n}\n"
    },
    "contracts/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721{\n\n//  events\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n//  view functions\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n\n//  Transaction functions\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    function approve(address _approved, uint256 _tokenId) external;\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n}"
    },
    "contracts/ERC721/NFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./IERC721.sol\";\nimport \"./ERC721Reciever.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Non FungibleToken Handeler\n * @author Darshil Mistry\n * @notice This is just designed to handle NFTS. The business logic can be found in the main solidity file.\n */\ncontract NFT is IERC721, ERC721Reciever {\n    // state variables\n    mapping(uint256 => address) TokenOwners;\n\n    mapping(uint256 => string) TokenURIs;\n\n    mapping(uint256 => address) Players;\n    /**\n     * @dev the tokenCount acts as the token ID\n     */\n    uint256 tokenCount;\n\n    mapping(address => uint256) Balances;\n\n    mapping(uint256 => address) TokenApprovals;\n\n    mapping(address => mapping(address => bool)) OperatorApprovals;\n\n    // immutables\n    string name;\n    string symbol;\n    address i_owner;\n\n    // events\n    event Coin_NewPlayerSignedUp(address player);\n    event Coin_TokenMinted(string tokenURI, uint256 tokenId);\n    \n    // errors\n    error Coin__foundTrespassing(address trespasser);\n    error Coin__contractNotERC721(bytes reason);\n    error Coin__managingUnOwnedToken(address sender);\n\n    // modifiers\n    /** \n    *@dev this modifier reverts if the message sender is not the deployer.\n    */\n    modifier authorizedPersonnelOnly() {\n        if (msg.sender != i_owner) revert Coin__foundTrespassing(msg.sender);\n        _;\n    }\n\n    // transaction functions\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n        i_owner = msg.sender;\n        tokenCount = 0;\n    }\n\n    /**\n     * @dev The mint function creates a token and adds the token to the owners address. \n     * Later when needed, the tokens can be transfered to another account. \n     */\n    function mint(string memory tokenURI) authorizedPersonnelOnly private returns (uint256) {\n        address owner = msg.sender;\n        Balances[owner] += 1;\n        attachURI(tokenCount, tokenURI);\n        TokenOwners[tokenCount] = owner;\n        emit Coin_TokenMinted(tokenURI, tokenCount);\n        return(tokenCount);\n    }\n\n    /**\n     * @dev This function works with the mint function to attach uris to newly generated NFTS \n     */\n    function attachURI(uint256 tokenID, string memory URI) private authorizedPersonnelOnly {\n        TokenURIs[tokenID] = URI;\n    }\n\n    /**\n     * @dev This function is used to apoint a third party to transfer a token \n     * for a spencific ID on the behalf of the owner.\n     * \n     * It will firstly check if the token being approved is actually owned by the sender.\n     */\n    function approve(address operator, uint256 tokenId) public override {\n        if(TokenOwners[tokenId] == msg.sender) { \n            TokenApprovals[tokenId] = operator;\n            emit Approval(msg.sender, operator, tokenId);\n        } else {\n            revert Coin__managingUnOwnedToken(msg.sender);\n        }\n    }\n\n    /**\n     * @dev This function can be used to appoint a third party to sell all of the tokens\n     * \n     * In this use case the third party would be another constract.\n     * It can be used to either provide or revoke the previllage.\n     */\n    function setApprovalForAll(\n        address operator,\n        bool approval\n    ) public override {\n        OperatorApprovals[msg.sender][operator] = approval;\n        emit ApprovalForAll(msg.sender, operator, approval);\n    }\n\n    /** \n     * @dev This function is used to transfer a token from one addres to another.\n     * \n     * it would first check if the message sender actually owns the token, \n     * if not it will be reverted.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public override {\n            if(TokenOwners[tokenId] == msg.sender) {\n            delete TokenApprovals[tokenId];\n            TokenOwners[tokenId] = to;\n            Balances[from] -= 1;\n            Balances[to] += 1;\n            emit Transfer(from, to, tokenId);\n        } else {\n            revert Coin__managingUnOwnedToken(msg.sender);\n        }\n    }\n\n    /**\n     * @dev this function first check if the reciever is a contract of a wallet. \n     * if its conttract it would be checked first that the contract would be able to handel the token.\n     * \n     * It can be used with an empty data element (\"\") but its not so secure  \n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public override {\n        checkOnERC721Received(from, to, tokenId, data);\n        transferFrom(from, to, tokenId);\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev This function is used to check if a reciever is a contract that can handle erc721 tokens. It is \n     * used before a safe transfer to prevent tokens getting stuck in places where the are not supposed to be 😅\n     */\n    function checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (Address.isContract(to)) {\n            try ERC721Reciever(to).onERC721Recieved( msg.sender, from, tokenId, data) returns (bytes4 retval) {\n                return retval == ERC721Reciever.onERC721Recieved.selector;\n            } catch (bytes memory reason) {\n                revert Coin__contractNotERC721(reason);\n            }\n        } else {\n            return true;\n        }\n    }\n\n    // public view functions\n\n    function balanceOf(address owner) public view override returns (uint256) {\n        return Balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return TokenOwners[tokenId];\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n        return TokenApprovals[tokenId];\n    }\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool) {\n        return OperatorApprovals[owner][operator];\n    }\n\n    function getName() public view returns (string memory) {\n        return name;\n    }\n\n    function getSymbol() public view returns (string memory) {\n        return symbol;\n    }\n\n    function onERC721Recieved(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external override returns (bytes4) {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}